<!DOCTYPE html>
<html lang="pt-BR" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analisador de Espectro IR</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src='https://cdn.plot.ly/plotly-latest.min.js'></script>
    <style>
        /* Custom Scrollbar for Webkit browsers */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #2d3748; /* gray-800 */
        }
        ::-webkit-scrollbar-thumb {
            background: #718096; /* gray-600 */
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #a0aec0; /* gray-500 */
        }
        /* Basic styles for range slider */
        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #4a5568; /* gray-700 */
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type=range]:hover {
            opacity: 1;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #63b3ed; /* blue-400 */
            border-radius: 50%;
            cursor: pointer;
        }
        input[type=range]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #63b3ed; /* blue-400 */
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        /* Style for region list items */
        .region-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 4px 0;
            font-size: 0.8rem; /* Smaller font for regions */
        }
        .region-item span {
            margin-right: 8px;
        }
        .remove-region-btn {
            background-color: #e53e3e; /* red-600 */
            color: white;
            border: none;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            font-size: 12px;
            line-height: 18px;
            text-align: center;
            cursor: pointer;
            padding: 0;
            margin-left: auto; /* Push button to the right */
        }
        .remove-region-btn:hover {
            background-color: #c53030; /* red-700 */
        }
        /* Ensure number inputs are visible in dark mode */
        input[type=number] {
            background-color: #4a5568; /* gray-700 */
            border: 1px solid #718096; /* gray-600 */
            color: #e2e8f0; /* gray-300 */
            border-radius: 4px;
            padding: 2px 6px;
            width: 70px; /* Adjust width as needed */
            -moz-appearance: textfield; /* Firefox */
        }
        input[type=number]::-webkit-outer-spin-button,
        input[type=number]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 font-sans flex h-screen overflow-hidden">

    <aside class="w-80 bg-gray-800 p-4 overflow-y-auto space-y-4 border-r border-gray-700 flex flex-col">
        <h1 class="text-xl font-semibold text-center mb-4">Analisador de Espectro IR</h1>

        <div class="space-y-2">
            <label for="filePure1" class="block text-sm font-medium">Substância Pura 1 (CSV):</label>
            <input type="file" id="filePure1" accept=".csv" class="block w-full text-sm text-gray-400
                file:mr-4 file:py-2 file:px-4
                file:rounded-md file:border-0
                file:text-sm file:font-semibold
                file:bg-blue-600 file:text-white
                hover:file:bg-blue-700 cursor-pointer">

            <label for="filePure2" class="block text-sm font-medium">Substância Pura 2 (CSV):</label>
            <input type="file" id="filePure2" accept=".csv" class="block w-full text-sm text-gray-400
                file:mr-4 file:py-2 file:px-4
                file:rounded-md file:border-0
                file:text-sm file:font-semibold
                file:bg-blue-600 file:text-white
                hover:file:bg-blue-700 cursor-pointer">

            <label for="fileMixture" class="block text-sm font-medium">Mistura Real (CSV):</label>
            <input type="file" id="fileMixture" accept=".csv" class="block w-full text-sm text-gray-400
                file:mr-4 file:py-2 file:px-4
                file:rounded-md file:border-0
                file:text-sm file:font-semibold
                file:bg-blue-600 file:text-white
                hover:file:bg-blue-700 cursor-pointer">
        </div>

        <fieldset class="border border-gray-600 p-3 rounded-md">
            <legend class="text-sm font-medium px-1">Pré-processamento</legend>
            <div class="space-y-2">
                <div class="flex items-center">
                    <input id="baselineCheckbox" type="checkbox" class="h-4 w-4 rounded border-gray-500 text-blue-600 focus:ring-blue-500 bg-gray-700">
                    <label for="baselineCheckbox" class="ml-2 block text-sm">Correção de Linha Base (Abs.)</label>
                </div>
                <div class="flex items-center">
                    <input id="normalizeCheckbox" type="checkbox" class="h-4 w-4 rounded border-gray-500 text-blue-600 focus:ring-blue-500 bg-gray-700">
                    <label for="normalizeCheckbox" class="ml-2 block text-sm">Normalizar Transmitância (0-1)</label>
                </div>
            </div>
        </fieldset>

        <fieldset class="border border-gray-600 p-3 rounded-md">
            <legend class="text-sm font-medium px-1">Cálculo da Mistura</legend>
            <div class="space-y-2">
                <div class="flex items-center">
                    <input id="modeManual" name="calcMode" type="radio" value="manual" checked class="h-4 w-4 border-gray-500 text-blue-600 focus:ring-blue-500 bg-gray-700">
                    <label for="modeManual" class="ml-2 block text-sm">Manual</label>
                </div>
                <div class="flex items-center">
                    <input id="modeAuto" name="calcMode" type="radio" value="auto" class="h-4 w-4 border-gray-500 text-blue-600 focus:ring-blue-500 bg-gray-700">
                    <label for="modeAuto" class="ml-2 block text-sm">Otimização Automática</label>
                </div>
            </div>

            <div id="manualControls" class="mt-3 space-y-1">
                 <label for="ratioSlider" class="block text-sm">Proporção Pura 1:</label>
                 <div class="flex items-center space-x-2">
                     <input type="range" id="ratioSlider" min="0" max="1" step="0.01" value="0.5" class="flex-grow">
                     <span id="ratioValue" class="text-sm font-mono w-10 text-right">0.50</span>
                 </div>
                 <div class="text-xs text-gray-400">Proporção Pura 2: <span id="ratioPure2Value">0.50</span></div>
            </div>

             <div id="autoResults" class="mt-3 space-y-1 hidden">
                <p class="text-sm">Razão Otimizada (Pura 1): <span id="optimizedRatio" class="font-mono font-semibold">-</span></p>
                <p class="text-sm">Erro (MSE): <span id="optimizedError" class="font-mono font-semibold">-</span></p>
            </div>
        </fieldset>

         <fieldset class="border border-gray-600 p-3 rounded-md">
            <legend class="text-sm font-medium px-1">Exibição do Gráfico (Eixo Y)</legend>
            <div class="space-y-2">
                <div class="flex items-center">
                    <input id="displayTransmittance" name="displayUnit" type="radio" value="transmittance" checked class="h-4 w-4 border-gray-500 text-blue-600 focus:ring-blue-500 bg-gray-700">
                    <label for="displayTransmittance" class="ml-2 block text-sm">Transmitância Corrigida (%)</label>
                </div>
                 <div class="flex items-center">
                    <input id="displayTransmittanceNorm" name="displayUnit" type="radio" value="transmittance_norm" class="h-4 w-4 border-gray-500 text-blue-600 focus:ring-blue-500 bg-gray-700">
                    <label for="displayTransmittanceNorm" class="ml-2 block text-sm">Transmitância Corrigida (norm.)</label>
                </div>
                <div class="flex items-center">
                    <input id="displayAbsorbance" name="displayUnit" type="radio" value="absorbance" class="h-4 w-4 border-gray-500 text-blue-600 focus:ring-blue-500 bg-gray-700">
                    <label for="displayAbsorbance" class="ml-2 block text-sm">Absorbância Corrigida</label>
                </div>
                <!-- New Feature: Difference Spectrum Checkbox -->
                <div class="flex items-center pt-2 border-t border-gray-700">
                    <input id="displayDifference" type="checkbox" class="h-4 w-4 rounded border-gray-500 text-blue-600 focus:ring-blue-500 bg-gray-700">
                    <label for="displayDifference" class="ml-2 block text-sm">Mostrar Espectro de Diferença</label>
                </div>
            </div>
        </fieldset>

        <fieldset class="border border-gray-600 p-3 rounded-md">
            <legend class="text-sm font-medium px-1">Regiões de Correlação (cm⁻¹)</legend>
            <div class="flex space-x-2 mb-2">
                <input type="number" id="regionStart" placeholder="Início" class="text-sm">
                <input type="number" id="regionEnd" placeholder="Fim" class="text-sm">
                <button id="addRegionBtn" class="px-3 py-1 bg-indigo-600 hover:bg-indigo-700 text-white text-sm font-semibold rounded-md transition duration-150 ease-in-out">+</button>
            </div>
            <div id="regionList" class="space-y-1 max-h-24 overflow-y-auto">
                </div>
        </fieldset>

        <button id="analyzeButton" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed" disabled>
            Analisar Espectros
        </button>

         <div class="space-y-2 pt-2 border-t border-gray-700">
             <button id="exportCsvButton" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                Exportar Teórico (CSV)
            </button>
             <button id="exportPngButton" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                Exportar Gráfico (PNG)
            </button>
        </div>

        <div class="flex-grow"></div>

        <div id="statusMessage" class="mt-auto text-xs text-center p-2 bg-gray-700 rounded min-h-[40px] flex items-center justify-center">
            Carregue os 3 arquivos CSV.
        </div>

    </aside>

    <main class="flex-1 flex flex-col p-4 bg-gray-900">
        <div id="plot" class="flex-grow bg-gray-800 rounded-lg border border-gray-700 min-h-[300px]">
            </div>
    </main>

    <script>
        // --- DOM Elements ---
        const fileInputs = {
            pure1: document.getElementById('filePure1'),
            pure2: document.getElementById('filePure2'),
            mixture: document.getElementById('fileMixture')
        };
        const baselineCheckbox = document.getElementById('baselineCheckbox');
        const normalizeCheckbox = document.getElementById('normalizeCheckbox');
        const modeManualRadio = document.getElementById('modeManual');
        const modeAutoRadio = document.getElementById('modeAuto');
        const manualControls = document.getElementById('manualControls');
        const autoResults = document.getElementById('autoResults');
        const ratioSlider = document.getElementById('ratioSlider');
        const ratioValueSpan = document.getElementById('ratioValue');
        const ratioPure2ValueSpan = document.getElementById('ratioPure2Value');
        const optimizedRatioSpan = document.getElementById('optimizedRatio');
        const optimizedErrorSpan = document.getElementById('optimizedError');
        const displayUnitRadios = document.querySelectorAll('input[name="displayUnit"]');
        const analyzeButton = document.getElementById('analyzeButton');
        const exportCsvButton = document.getElementById('exportCsvButton');
        const exportPngButton = document.getElementById('exportPngButton');
        const statusMessageDiv = document.getElementById('statusMessage');
        const plotDiv = document.getElementById('plot');
        const displayTransmittanceNormRadio = document.getElementById('displayTransmittanceNorm');
        const displayDifferenceCheckbox = document.getElementById('displayDifference'); // New element
        // New elements for correlation regions
        const regionStartInput = document.getElementById('regionStart');
        const regionEndInput = document.getElementById('regionEnd');
        const addRegionBtn = document.getElementById('addRegionBtn');
        const regionListDiv = document.getElementById('regionList');


        // --- Global State ---
        let rawSpectra = { pure1: null, pure2: null, mixture: null };
        let processedSpectra = { pure1: null, pure2: null, mixture: null }; // Holds data after unit conversion and potential baseline correction (in Absorbance)
        let finalTransmittanceSpectra = { pure1: null, pure2: null, mixture: null }; // Holds final Transmittance data (corrected, possibly normalized) used for alignment and calculation
        let alignedSpectra = { pure1: null, pure2: null, mixture: null }; // Holds aligned spectra based on common wavenumbers (final T% units)
        let commonWavenumbers = [];
        let theoreticalSpectrum = { wavenumbers: [], values: [] };
        let plotInstance = null;
        let currentSettings = {
            baselineCorrect: false,
            normalize: false,
            mode: 'manual', // 'manual' or 'auto'
            manualRatio: 0.5,
            optimizedRatio: null,
            displayUnit: 'transmittance', // 'transmittance', 'transmittance_norm', 'absorbance'
            displayDifference: false // New setting
        };
        let definedRegions = []; // Array to store {id: number, start: number, end: number}
        let nextRegionId = 0; // Simple ID generator for regions
        let lastMessageTimeout = null;

        // --- Utility Functions ---
        function displayMessage(message, type = 'info', duration = 5000) {
            console.log(`Message (${type}): ${message}`);
            clearTimeout(lastMessageTimeout);
            statusMessageDiv.textContent = message;
            statusMessageDiv.classList.remove('text-red-400', 'text-green-400', 'text-yellow-400', 'text-gray-400');
            switch (type) {
                case 'error': statusMessageDiv.classList.add('text-red-400'); break;
                case 'success': statusMessageDiv.classList.add('text-green-400'); break;
                case 'warning': statusMessageDiv.classList.add('text-yellow-400'); break;
                default: statusMessageDiv.classList.add('text-gray-400'); // Info
            }
             if (duration > 0) {
                lastMessageTimeout = setTimeout(() => {
                     if (statusMessageDiv.textContent === message) { // Only clear if it's the same message
                        statusMessageDiv.textContent = 'Pronto.';
                        statusMessageDiv.classList.remove('text-red-400', 'text-green-400', 'text-yellow-400');
                         statusMessageDiv.classList.add('text-gray-400');
                    }
                }, duration);
            }
        }

        function parseCSV(csvText) {
            const lines = csvText.trim().split(/\r?\n/);
            const data = [];
            let headerSkipped = false;

            if (lines.length === 0) {
                throw new Error("Arquivo CSV vazio.");
            }

            // Simple header detection: check if second column of first line is not a number
            const firstLineCols = lines[0].split(/[,;\t]/).map(s => s.trim());
            if (firstLineCols.length < 2 || isNaN(parseFloat(firstLineCols[1]))) {
                 console.log("Potencial cabeçalho detectado, pulando primeira linha.");
                lines.shift(); // Remove header line
                headerSkipped = true;
            }

            for (const line of lines) {
                const columns = line.split(/[,;\t]/).map(s => s.trim());
                if (columns.length >= 2) {
                    const wavenumber = parseFloat(columns[0]);
                    const value = parseFloat(columns[1]);
                    if (!isNaN(wavenumber) && !isNaN(value)) {
                        data.push({ wavenumber, value });
                    } else {
                         console.warn(`Linha ignorada por dados inválidos: ${line}`);
                    }
                }
            }
             if (data.length === 0) {
                 throw new Error(`Nenhum dado numérico válido encontrado no CSV${headerSkipped ? ' após pular o cabeçalho' : ''}. Verifique o formato (Wavenumber, Value).`);
            }
            // Sort by wavenumber ascending (important for interpolation)
            data.sort((a, b) => a.wavenumber - b.wavenumber);
            return data; // [{wavenumber: num, value: num}, ...]
        }

         function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = event => resolve(event.target.result);
                reader.onerror = error => reject(error);
                reader.readAsText(file);
            });
        }

        function checkAllFilesLoaded() {
            const allLoaded = rawSpectra.pure1 && rawSpectra.pure2 && rawSpectra.mixture;
            analyzeButton.disabled = !allLoaded;
             exportCsvButton.disabled = true; // Disable until analysis is done
             exportPngButton.disabled = true;
             // Also disable region adding if files aren't loaded? Maybe not necessary.
            if (allLoaded) {
                displayMessage('Todos os arquivos carregados. Pronto para analisar.', 'success', 0);
            } else {
                const missing = ['pure1', 'pure2', 'mixture'].filter(key => !rawSpectra[key]);
                displayMessage(`Carregue os arquivos CSV para: ${missing.join(', ')}`, 'info', 0);
            }
            return allLoaded;
        }

        // Linear interpolation function
        function interpolate(x, xPoints, yPoints) {
            if (x <= xPoints[0]) return yPoints[0];
            if (x >= xPoints[xPoints.length - 1]) return yPoints[yPoints.length - 1];

            let low = 0;
            let high = xPoints.length - 1;
            let mid;

            // Binary search to find the interval
            while (low <= high) {
                mid = Math.floor((low + high) / 2);
                if (xPoints[mid] === x) return yPoints[mid];
                if (xPoints[mid] < x) {
                    low = mid + 1;
                } else {
                    high = mid - 1;
                }
            }
            // low is now the index of the upper bound
            const i = low; // upper bound index
            const x1 = xPoints[i - 1];
            const y1 = yPoints[i - 1];
            const x2 = xPoints[i];
            const y2 = yPoints[i];

             // Avoid division by zero if wavenumbers are identical (shouldn't happen with sorted distinct data)
            if (x2 === x1) return y1;

            // Linear interpolation formula
            return y1 + (x - x1) * (y2 - y1) / (x2 - x1);
        }

         // Calculate Absorbance from Transmittance (%)
        function transmittanceToAbsorbance(tPercent) {
            if (tPercent <= 0) return 5; // Avoid log(0) or log(-ve), return high absorbance
            return 2 - Math.log10(tPercent);
        }

        // Calculate Transmittance (%) from Absorbance
        function absorbanceToTransmittance(absorbance) {
            // Prevent extremely high transmittance from negative absorbance after baseline correction
            if (absorbance < -3) return 1000; // Cap T% if A is very negative
            return Math.pow(10, 2 - absorbance);
        }

         // Calculate Pearson Correlation Coefficient
        function calculatePearsonCorrelation(arr1, arr2) {
            if (arr1.length !== arr2.length || arr1.length < 2) {
                return NaN; // Not enough data or mismatched lengths
            }

            const n = arr1.length;
            const sumX = arr1.reduce((a, b) => a + b, 0);
            const sumY = arr2.reduce((a, b) => a + b, 0);
            const meanX = sumX / n;
            const meanY = sumY / n;

            let sumXY = 0;
            let sumX2 = 0;
            let sumY2 = 0;

            for (let i = 0; i < n; i++) {
                const devX = arr1[i] - meanX;
                const devY = arr2[i] - meanY;
                sumXY += devX * devY;
                sumX2 += devX * devX;
                sumY2 += devY * devY;
            }

            const denominator = Math.sqrt(sumX2) * Math.sqrt(sumY2);
            if (denominator === 0) {
                return NaN; // Avoid division by zero (happens if one array is constant)
            }

            return sumXY / denominator;
        }


        // --- Event Handlers ---
        Object.keys(fileInputs).forEach(key => {
            fileInputs[key].addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if (!file) {
                    rawSpectra[key] = null;
                    processedSpectra[key] = null;
                    finalTransmittanceSpectra[key] = null;
                    alignedSpectra[key] = null;
                    checkAllFilesLoaded();
                    return;
                }
                displayMessage(`Lendo ${file.name}...`, 'info', 0);
                try {
                    const text = await readFileAsText(file);
                    rawSpectra[key] = parseCSV(text);
                    displayMessage(`${file.name} lido com sucesso (${rawSpectra[key].length} pontos).`, 'success');
                    checkAllFilesLoaded();
                } catch (error) {
                    displayMessage(`Erro ao ler ${file.name}: ${error.message}`, 'error');
                    rawSpectra[key] = null;
                    checkAllFilesLoaded();
                }
            });
        });

        baselineCheckbox.addEventListener('change', (e) => {
            currentSettings.baselineCorrect = e.target.checked;
             // Re-analyze if data is loaded to reflect the change immediately
             if (checkAllFilesLoaded()) {
                 analyzeButton.click();
             }
        });

        normalizeCheckbox.addEventListener('change', (e) => {
            currentSettings.normalize = e.target.checked;
            displayTransmittanceNormRadio.disabled = !currentSettings.normalize;
            if (!currentSettings.normalize && currentSettings.displayUnit === 'transmittance_norm') {
                // If normalization is turned off, switch display to regular transmittance
                 document.getElementById('displayTransmittance').checked = true;
                 currentSettings.displayUnit = 'transmittance';
                 // No need to re-analyze fully, just update plot display if data exists
                 if (alignedSpectra.pure1) updatePlot();
            } else {
                // Re-analyze if data is loaded to reflect the change immediately
                 if (checkAllFilesLoaded()) {
                     analyzeButton.click();
                 }
            }
        });

        modeManualRadio.addEventListener('change', () => {
            currentSettings.mode = 'manual';
            manualControls.classList.remove('hidden');
            autoResults.classList.add('hidden');
            if (alignedSpectra.pure1) { // Only update plot if data exists
                calculateAndPlot();
            }
        });

        modeAutoRadio.addEventListener('change', () => {
            currentSettings.mode = 'auto';
            manualControls.classList.add('hidden');
            autoResults.classList.remove('hidden');
             if (alignedSpectra.pure1) { // Only update plot if data exists
                calculateAndPlot(); // Will trigger optimization if mode is auto
            }
        });

        ratioSlider.addEventListener('input', (e) => {
            currentSettings.manualRatio = parseFloat(e.target.value);
            ratioValueSpan.textContent = currentSettings.manualRatio.toFixed(2);
            ratioPure2ValueSpan.textContent = (1 - currentSettings.manualRatio).toFixed(2);
             if (currentSettings.mode === 'manual' && alignedSpectra.pure1) {
                calculateTheoreticalSpectrum(currentSettings.manualRatio);
                updatePlot(); // This will recalculate correlations as well
            }
        });

        displayUnitRadios.forEach(radio => {
            radio.addEventListener('change', (e) => {
                 if (e.target.checked) {
                    currentSettings.displayUnit = e.target.value;
                     updatePlot(); // Re-render plot with new units and correlations if data exists
                }
            });
        });

        // New event listener for the difference spectrum checkbox
        displayDifferenceCheckbox.addEventListener('change', (e) => {
            currentSettings.displayDifference = e.target.checked;
            if (alignedSpectra.pure1) { // Only update plot if data is loaded
                updatePlot();
            }
        });

        // --- Region Management ---
        addRegionBtn.addEventListener('click', () => {
            const start = parseFloat(regionStartInput.value);
            const end = parseFloat(regionEndInput.value);

            if (isNaN(start) || isNaN(end)) {
                displayMessage("Valores de início e fim da região devem ser números.", "warning");
                return;
            }
            if (start >= end) {
                 displayMessage("O início da região deve ser menor que o fim.", "warning");
                 return;
            }

             // Ensure wavenumbers are ordered correctly (higher value on left means start > end visually)
            const region = { id: nextRegionId++, start: Math.max(start, end), end: Math.min(start, end) }; // Store as {start: higher_wn, end: lower_wn}

            definedRegions.push(region);
            renderRegionList();
            regionStartInput.value = '';
            regionEndInput.value = '';

             // If data is already plotted, update plot with new region correlation
             if (plotInstance) {
                 updatePlot();
             }
        });

        function renderRegionList() {
            regionListDiv.innerHTML = ''; // Clear current list
            definedRegions.forEach(region => {
                const div = document.createElement('div');
                div.classList.add('region-item');
                div.dataset.regionId = region.id; // Store ID for removal
                div.innerHTML = `
                    <span>${region.end.toFixed(0)} - ${region.start.toFixed(0)} cm⁻¹</span>
                    <button class="remove-region-btn" title="Remover Região">&times;</button>
                `;
                // Add event listener to the remove button
                div.querySelector('.remove-region-btn').addEventListener('click', () => {
                    removeRegion(region.id);
                });
                regionListDiv.appendChild(div);
            });
        }

        function removeRegion(idToRemove) {
            definedRegions = definedRegions.filter(region => region.id !== idToRemove);
            renderRegionList();
             // If data is already plotted, update plot to remove the region's correlation
             if (plotInstance) {
                 updatePlot();
             }
        }
        // --- End Region Management ---


        analyzeButton.addEventListener('click', () => {
            if (!checkAllFilesLoaded()) return;
            displayMessage('Analisando...', 'info', 0);
             analyzeButton.disabled = true; // Disable button during analysis
            exportCsvButton.disabled = true;
            exportPngButton.disabled = true;

            // Use setTimeout to allow UI update before heavy computation
            setTimeout(() => {
                 try {
                     // 1. Preprocessing (Unit Conversion, Baseline Correction, Convert back to T%, Normalization)
                    preprocessAllSpectra();

                    // 2. Alignment
                    alignAllSpectra();

                    // 3. Calculation (Manual or Auto) & Plotting (includes correlation)
                    calculateAndPlot();

                    displayMessage('Análise concluída.', 'success');
                     exportCsvButton.disabled = false; // Enable export after successful analysis
                    exportPngButton.disabled = false;

                } catch (error) {
                     displayMessage(`Erro na análise: ${error.message}`, 'error');
                     console.error("Analysis Error:", error);
                     // Clear potentially inconsistent intermediate data
                     processedSpectra = { pure1: null, pure2: null, mixture: null };
                     finalTransmittanceSpectra = { pure1: null, pure2: null, mixture: null };
                     alignedSpectra = { pure1: null, pure2: null, mixture: null };
                     commonWavenumbers = [];
                     theoreticalSpectrum = { wavenumbers: [], values: [] };
                     Plotly.purge(plotDiv); // Clear plot on error
                     plotInstance = null;
                     exportCsvButton.disabled = true;
                     exportPngButton.disabled = true;
                } finally {
                    analyzeButton.disabled = false; // Re-enable button
                 }
            }, 50); // Small delay
        });

         exportCsvButton.addEventListener('click', exportTheoreticalCSV);
         exportPngButton.addEventListener('click', exportPlotPNG);

        // --- Core Logic Functions ---

        function preprocessAllSpectra() {
            displayMessage('Pré-processando dados...', 'info', 0);
            let conversionMessages = [];
            ['pure1', 'pure2', 'mixture'].forEach(key => {
                if (!rawSpectra[key]) throw new Error(`Dados brutos ausentes para ${key}`);

                let wavenumbers = rawSpectra[key].map(p => p.wavenumber);
                let values = rawSpectra[key].map(p => p.value);
                let initialUnit = 'absorbance'; // Default assumption

                // Simple Unit Detection
                const avgValue = values.reduce((a, b) => a + b, 0) / values.length;
                const allPositive = values.every(v => v >= 0);
                const likelyTransmittance = avgValue > 3 && allPositive && Math.max(...values) <= 110; // Refined heuristic for T% (0-100 range)

                if (likelyTransmittance) {
                    initialUnit = 'transmittance';
                    conversionMessages.push(`Detectado ${key} como Transmitância (%), convertendo para Absorbância.`);
                    values = values.map(t => transmittanceToAbsorbance(t));
                 } else {
                     conversionMessages.push(`Assumindo ${key} como Absorbância.`);
                 }

                 // Store initial absorbance data before baseline correction
                 let absorbanceData = [...values];

                 // Optional Baseline Correction (on Absorbance)
                 if (currentSettings.baselineCorrect) {
                     // Simple baseline: subtract minimum value
                     const minAbsorbance = Math.min(...absorbanceData.filter(isFinite)); // Filter out potential Infs/NaNs
                     if (isFinite(minAbsorbance)) {
                         absorbanceData = absorbanceData.map(a => isFinite(a) ? (a - minAbsorbance) : a); // Apply correction only to finite values
                         conversionMessages.push(`Correção de linha base (Abs) aplicada para ${key}.`);
                     } else {
                         console.warn(`Não foi possível encontrar o mínimo de absorbância finito para ${key}, correção pulada.`);
                    }
                }

                 // Store the processed absorbance spectrum
                 processedSpectra[key] = { wavenumbers: [...wavenumbers], values: [...absorbanceData] };

                 // Convert back to Transmittance (%) for alignment and calculation
                 let finalTransmittanceValues = absorbanceData.map(a => absorbanceToTransmittance(a));

                // Optional Normalization (on final Transmittance %)
                 if (currentSettings.normalize) {
                    const finiteTValues = finalTransmittanceValues.filter(isFinite);
                    if (finiteTValues.length > 0) {
                        const minT = Math.min(...finiteTValues);
                        const maxT = Math.max(...finiteTValues);
                        const rangeT = maxT - minT;

                        if (rangeT > 1e-6) { // Avoid division by zero if range is tiny
                            finalTransmittanceValues = finalTransmittanceValues.map(t => isFinite(t) ? (t - minT) / rangeT : NaN); // Normalize finite values, keep NaN as NaN
                            conversionMessages.push(`Transmitância normalizada (0-1) para ${key}.`);
                        } else { // Handle constant value case
                            finalTransmittanceValues = finalTransmittanceValues.map(t => isFinite(t) ? 0.5 : NaN); // Set finite values to 0.5
                            console.warn(`Intervalo de transmitância finito muito pequeno para normalização em ${key}. Definindo como 0.5.`);
                        }
                    } else {
                        console.warn(`Nenhum valor de transmitância finito encontrado para ${key} após pré-processamento. Normalização pulada.`);
                    }
                 }

                 // Store the final Transmittance spectrum (used for alignment/calculation)
                 finalTransmittanceSpectra[key] = { wavenumbers: [...wavenumbers], values: finalTransmittanceValues };
            });
            // Display consolidated messages after loop
            conversionMessages.forEach(msg => displayMessage(msg, 'info', 3000));
            displayMessage('Pré-processamento concluído.', 'success');
        }


        function alignAllSpectra() {
            if (!finalTransmittanceSpectra.pure1 || !finalTransmittanceSpectra.pure2 || !finalTransmittanceSpectra.mixture) {
                 throw new Error("Dados pré-processados ausentes para alinhamento.");
            }
            displayMessage('Alinhando espectros...', 'info', 0);

            // Find common wavenumber range based on *finite* start/end points
             const getFiniteRange = (spectrum) => {
                const firstFiniteIndex = spectrum.wavenumbers.findIndex((wn, i) => isFinite(wn) && isFinite(spectrum.values[i]));
                const lastFiniteIndex = spectrum.wavenumbers.findLastIndex((wn, i) => isFinite(wn) && isFinite(spectrum.values[i]));
                 if (firstFiniteIndex === -1 || lastFiniteIndex === -1) return { min: Infinity, max: -Infinity };
                 return { min: spectrum.wavenumbers[firstFiniteIndex], max: spectrum.wavenumbers[lastFiniteIndex] };
             };

            const range1 = getFiniteRange(finalTransmittanceSpectra.pure1);
            const range2 = getFiniteRange(finalTransmittanceSpectra.pure2);
            const rangeMix = getFiniteRange(finalTransmittanceSpectra.mixture);

            const minWavenumber = Math.max(range1.min, range2.min, rangeMix.min);
            const maxWavenumber = Math.min(range1.max, range2.max, rangeMix.max);


            if (!isFinite(minWavenumber) || !isFinite(maxWavenumber) || minWavenumber >= maxWavenumber) {
                throw new Error(`Nenhum intervalo de número de onda sobreposto com dados finitos encontrado (Min: ${minWavenumber.toFixed(2)}, Max: ${maxWavenumber.toFixed(2)}).`);
            }

            // Use mixture's wavenumbers within the common range as the target grid
            commonWavenumbers = finalTransmittanceSpectra.mixture.wavenumbers.filter(wn => wn >= minWavenumber && wn <= maxWavenumber && isFinite(wn));

             if (commonWavenumbers.length < 2) { // Need at least 2 points for meaningful comparison/plotting
                throw new Error(`Intervalo de número de onda sobreposto muito pequeno (${commonWavenumbers.length} pontos finitos).`);
            }


            // Interpolate Pure1 and Pure2 onto the commonWavenumbers grid using their final transmittance values
            // Ensure the source data for interpolation is finite
             const finitePure1 = finalTransmittanceSpectra.pure1.wavenumbers.map((wn, i) => ({ wn, val: finalTransmittanceSpectra.pure1.values[i] })).filter(p => isFinite(p.wn) && isFinite(p.val));
             const finitePure2 = finalTransmittanceSpectra.pure2.wavenumbers.map((wn, i) => ({ wn, val: finalTransmittanceSpectra.pure2.values[i] })).filter(p => isFinite(p.wn) && isFinite(p.val));

             if (finitePure1.length < 2 || finitePure2.length < 2) {
                 throw new Error("Dados finitos insuficientes nos espectros puros para interpolação.");
             }

            alignedSpectra.pure1 = {
                wavenumbers: [...commonWavenumbers],
                values: commonWavenumbers.map(wn => interpolate(wn, finitePure1.map(p=>p.wn), finitePure1.map(p=>p.val)))
            };
            alignedSpectra.pure2 = {
                wavenumbers: [...commonWavenumbers],
                values: commonWavenumbers.map(wn => interpolate(wn, finitePure2.map(p=>p.wn), finitePure2.map(p=>p.val)))
            };

            // Get Mixture values directly at the common wavenumbers, ensuring they are finite
            const mixtureMap = new Map(finalTransmittanceSpectra.mixture.wavenumbers.map((wn, i) => [wn, finalTransmittanceSpectra.mixture.values[i]]));
            alignedSpectra.mixture = {
                wavenumbers: [...commonWavenumbers],
                values: commonWavenumbers.map(wn => {
                    const val = mixtureMap.get(wn);
                    return isFinite(val) ? val : NaN; // Use NaN if mixture value at common wn is not finite
                })
            };

             // Final check: ensure aligned spectra have finite values for calculation
             alignedSpectra.pure1.values = alignedSpectra.pure1.values.map(v => isFinite(v) ? v : NaN);
             alignedSpectra.pure2.values = alignedSpectra.pure2.values.map(v => isFinite(v) ? v : NaN);

            displayMessage(`Espectros alinhados para ${commonWavenumbers.length} pontos entre ${minWavenumber.toFixed(2)} e ${maxWavenumber.toFixed(2)} cm⁻¹.`, 'success');
        }


        function calculateTheoreticalSpectrum(ratio) {
            if (!alignedSpectra.pure1 || !alignedSpectra.pure2) {
                 console.error("Espectros alinhados ausentes para cálculo teórico.");
                 theoreticalSpectrum = { wavenumbers: [], values: [] }; // Reset
                 return;
            }

            theoreticalSpectrum.wavenumbers = [...commonWavenumbers];
            theoreticalSpectrum.values = alignedSpectra.pure1.values.map((val1, i) => {
                 const val2 = alignedSpectra.pure2.values[i];
                 // If either input value is NaN, the result is NaN
                 if (isNaN(val1) || isNaN(val2)) return NaN;
                return (ratio * val1) + ((1 - ratio) * val2);
            });
        }

        function optimizeRatio() {
             if (!alignedSpectra.pure1 || !alignedSpectra.pure2 || !alignedSpectra.mixture) {
                 throw new Error("Espectros alinhados ausentes para otimização.");
            }
             displayMessage('Otimizando razão da mistura...', 'info', 0);

            let bestRatio = 0.5; // Start guess
            let minMSE = Infinity;

            // Filter out points where any of the three spectra have NaN values
            const indicesToCompare = commonWavenumbers.map((_, i) => i).filter(i =>
                !isNaN(alignedSpectra.pure1.values[i]) &&
                !isNaN(alignedSpectra.pure2.values[i]) &&
                !isNaN(alignedSpectra.mixture.values[i])
            );

            const N = indicesToCompare.length;
            if (N < 2) throw new Error("Pontos de dados finitos e sobrepostos insuficientes (<2) para otimização.");

            for (let ratio = 0; ratio <= 1.0; ratio += 0.01) { // Simple grid search
                 ratio = Math.round(ratio * 100) / 100; // Avoid floating point issues
                let currentMSE = 0;
                for (const i of indicesToCompare) {
                    const theoreticalVal = (ratio * alignedSpectra.pure1.values[i]) + ((1 - ratio) * alignedSpectra.pure2.values[i]);
                    const realVal = alignedSpectra.mixture.values[i];
                    currentMSE += Math.pow(theoreticalVal - realVal, 2);
                }
                currentMSE /= N;

                if (currentMSE < minMSE) {
                    minMSE = currentMSE;
                    bestRatio = ratio;
                }
            }

             currentSettings.optimizedRatio = bestRatio;
             optimizedRatioSpan.textContent = bestRatio.toFixed(2);
             optimizedErrorSpan.textContent = minMSE.toExponential(3); // Display MSE in scientific notation

             displayMessage(`Otimização concluída. Melhor razão: ${bestRatio.toFixed(2)}, MSE: ${minMSE.toExponential(3)}`, 'success');
             return bestRatio;
        }


        function calculateAndPlot() {
             if (!alignedSpectra.mixture) {
                 console.warn("Nenhum espectro alinhado para calcular/plotar.");
                 return;
             }
             let ratioToUse;
            if (currentSettings.mode === 'auto') {
                 ratioToUse = optimizeRatio(); // This updates currentSettings.optimizedRatio
            } else {
                ratioToUse = currentSettings.manualRatio;
                // Ensure manual display is correct
                ratioSlider.value = ratioToUse;
                ratioValueSpan.textContent = ratioToUse.toFixed(2);
                ratioPure2ValueSpan.textContent = (1 - ratioToUse).toFixed(2);
                 // Clear auto results display
                optimizedRatioSpan.textContent = '-';
                optimizedErrorSpan.textContent = '-';
            }

            calculateTheoreticalSpectrum(ratioToUse);
            updatePlot(); // This now includes correlation calculation
        }


        function updatePlot() {
             if (!alignedSpectra.mixture || !theoreticalSpectrum.values.length) {
                 // Clear plot if no data
                 Plotly.purge(plotDiv);
                 plotInstance = null;
                 exportPngButton.disabled = true;
                 exportCsvButton.disabled = true; // Also disable CSV if plot can't be generated
                 console.warn("Dados insuficientes para plotagem.");
                return;
            }

            displayMessage('Atualizando gráfico...', 'info', 0);

            let yAxisTitle = '';
            let yValuesReal = [];
            let yValuesTheoretical = [];
            let yRange = undefined; // Let Plotly decide by default

            const finalRealValues = alignedSpectra.mixture.values; // These are final T% (possibly normalized 0-1 or NaN)
            const finalTheoreticalValues = theoreticalSpectrum.values; // These are calculated from final T% (or NaN)

            // --- Determine Y values based on display unit ---
            switch (currentSettings.displayUnit) {
                case 'transmittance':
                    yAxisTitle = currentSettings.normalize ? 'Transmitância Corrigida (norm.)' : 'Transmitância Corrigida (%)';
                    yValuesReal = finalRealValues;
                    yValuesTheoretical = finalTheoreticalValues;
                    // Set range based on normalization, considering only finite values
                    const finiteT = [...finalRealValues, ...finalTheoreticalValues].filter(isFinite);
                    if (finiteT.length > 0) {
                         yRange = currentSettings.normalize ? [0, 1] : [0, Math.max(100, Math.max(...finiteT) * 1.05)];
                    } else {
                         yRange = currentSettings.normalize ? [0, 1] : [0, 100]; // Default range if no finite data
                    }
                    break;
                case 'transmittance_norm':
                     if (!currentSettings.normalize) {
                        displayMessage("Selecione 'Normalizar Transmitância' para ver a exibição normalizada.", "warning");
                         document.getElementById('displayTransmittance').checked = true;
                         currentSettings.displayUnit = 'transmittance';
                         updatePlot(); // Re-call with corrected setting
                         return; // Stop current execution
                    }
                    yAxisTitle = 'Transmitância Corrigida (norm.)';
                    yValuesReal = finalRealValues; // Should already be 0-1 or NaN
                    yValuesTheoretical = finalTheoreticalValues; // Should already be 0-1 or NaN
                    yRange = [0, 1];
                    break;
                case 'absorbance':
                     yAxisTitle = 'Absorbância Corrigida';
                    const convertToAbs = (t) => {
                         if (isNaN(t)) return NaN; // Preserve NaN
                        if (currentSettings.normalize) { // Input is 0-1
                            if (t <= 1e-5) return 5; // T=0.00001 -> A=5
                             return -Math.log10(t);
                        } else { // Input is 0-100%
                            return transmittanceToAbsorbance(t);
                        }
                    };
                    yValuesReal = finalRealValues.map(convertToAbs);
                    yValuesTheoretical = finalTheoreticalValues.map(convertToAbs);
                    // Determine Absorbance range from finite values
                    const finiteAbs = [...yValuesReal, ...yValuesTheoretical].filter(isFinite);
                     if (finiteAbs.length > 0) {
                         const maxAbs = Math.max(...finiteAbs);
                         yRange = [0, Math.max(0.1, maxAbs * 1.1)]; // Ensure range is at least 0-0.1
                     } else {
                         yRange = [0, 1]; // Default range if no finite absorbance
                     }
                    break;
            }
            // --- End Y value determination ---


            const traceReal = {
                x: commonWavenumbers,
                y: yValuesReal,
                mode: 'lines',
                name: 'Mistura Real (Processada)',
                line: { color: '#F87171', width: 1.5 }, // red-400
                connectgaps: false // Do not connect over NaN values
            };

            const traceTheoretical = {
                x: commonWavenumbers,
                y: yValuesTheoretical,
                mode: 'lines',
                name: `Mistura Teórica (R=${(currentSettings.mode === 'auto' ? currentSettings.optimizedRatio : currentSettings.manualRatio).toFixed(2)})`,
                line: { color: '#60A5FA', width: 1.5, dash: 'dash' }, // blue-400
                connectgaps: false // Do not connect over NaN values
            };
            
            let traces = [traceReal, traceTheoretical];

            const layout = {
                title: 'Comparação de Espectro: Real vs. Teórico',
                 xaxis: {
                    title: 'Número de Onda (cm⁻¹)',
                    autorange: 'reversed', // Higher values on the left
                    gridcolor: '#4A5568', // gray-700
                    linecolor: '#718096', // gray-600
                    zerolinecolor: '#718096'
                 },
                 yaxis: {
                    title: yAxisTitle,
                    range: yRange, // Apply calculated range
                    gridcolor: '#4A5568',
                    linecolor: '#718096',
                    zerolinecolor: '#718096',
                    zeroline: true,
                    fixedrange: false // Allow zooming on Y axis
                },
                 legend: {
                     yanchor: "top",
                    y: 0.99,
                    xanchor: "left",
                    x: 0.01,
                    bgcolor: 'rgba(45, 55, 72, 0.8)', // gray-800 with transparency
                    bordercolor: '#718096',
                    borderwidth: 1
                },
                plot_bgcolor: '#1A202C', // gray-900
                paper_bgcolor: '#2D3748', // gray-800
                font: {
                    color: '#E2E8F0' // gray-300
                },
                margin: { l: 60, r: 50, t: 50, b: 50 }, // Adjust right margin for second axis
                shapes: [], // Initialize shapes array for regions and thresholds
                annotations: [] // Initialize annotations array for correlation text
            };

            // --- Add Difference Spectrum if enabled ---
            if(currentSettings.displayDifference) {
                const yValuesDifference = yValuesReal.map((val, i) => {
                    const theoVal = yValuesTheoretical[i];
                    if (isNaN(val) || isNaN(theoVal)) return NaN;
                    return val - theoVal;
                });

                const traceDifference = {
                    x: commonWavenumbers,
                    y: yValuesDifference,
                    mode: 'lines',
                    name: 'Diferença (Real - Teórico)',
                    line: { color: '#FBBF24', width: 1.2 }, // amber-400
                    yaxis: 'y2', // Assign to the second y-axis
                    connectgaps: false
                };
                
                traces.push(traceDifference);
                
                // --- NEW: Define fixed range and thresholds for difference axis ---
                let diff_range;
                let threshold_val;

                if (currentSettings.displayUnit === 'transmittance_norm' || (currentSettings.displayUnit === 'transmittance' && currentSettings.normalize)) {
                    diff_range = [-1.1, 1.1];
                    threshold_val = 0.1;
                } else if (currentSettings.displayUnit === 'transmittance' && !currentSettings.normalize) {
                    diff_range = [-110, 110];
                    threshold_val = 10;
                } else { // Absorbance
                    const main_range_size = yRange[1] - yRange[0];
                    diff_range = [-main_range_size * 1.1, main_range_size * 1.1];
                    threshold_val = main_range_size * 0.1;
                }

                // Add the second y-axis to the layout with the fixed range
                layout.yaxis2 = {
                    title: 'Diferença',
                    overlaying: 'y',
                    side: 'right',
                    showgrid: false,
                    zeroline: true,
                    zerolinecolor: '#A0AEC0', // gray-500
                    zerolinewidth: 1,
                    linecolor: '#718096',
                    font: { color: '#CBD5E0' }, // gray-400
                    range: diff_range // Apply the fixed range
                };

                // Add threshold lines to the layout shapes
                const threshold_style = {
                    type: 'line',
                    xref: 'paper', // Span the full width of the plot
                    x0: 0,
                    x1: 1,
                    yref: 'y2', // Refer to the second y-axis
                    line: {
                        color: '#718096', // gray-600
                        width: 1,
                        dash: 'dash'
                    }
                };
                layout.shapes.push({ ...threshold_style, y0: threshold_val, y1: threshold_val });
                layout.shapes.push({ ...threshold_style, y0: -threshold_val, y1: -threshold_val });
            }


            // --- Calculate and Add Correlation Annotations/Shapes ---
            definedRegions.forEach((region, index) => {
                const { start, end } = region; // start is higher WN, end is lower WN

                // Find indices within the common wavenumbers that fall into this region
                const regionIndices = commonWavenumbers.reduce((acc, wn, i) => {
                    if (wn <= start && wn >= end) {
                        acc.push(i);
                    }
                    return acc;
                }, []);

                // Filter the Y data (currently plotted) for the region, excluding NaNs
                const realRegionY = regionIndices.map(i => yValuesReal[i]).filter(y => !isNaN(y));
                const theoRegionY = regionIndices.map(i => yValuesTheoretical[i]).filter(y => !isNaN(y));

                let correlation = NaN;
                let annotationText = `Região ${index + 1}<br>(${end.toFixed(0)}-${start.toFixed(0)} cm⁻¹)<br>R: ---`;

                if (realRegionY.length >= 2 && theoRegionY.length >= 2 && realRegionY.length === theoRegionY.length) {
                    correlation = calculatePearsonCorrelation(realRegionY, theoRegionY);
                    if (!isNaN(correlation)) {
                         annotationText = `Região ${index + 1}<br>(${end.toFixed(0)}-${start.toFixed(0)} cm⁻¹)<br>R: ${correlation.toFixed(3)}`;
                    } else {
                         annotationText = `Região ${index + 1}<br>(${end.toFixed(0)}-${start.toFixed(0)} cm⁻¹)<br>R: Inválido`; // e.g., constant data
                    }
                } else {
                     console.warn(`Dados insuficientes ou incompatíveis na Região ${index + 1} (${end.toFixed(0)}-${start.toFixed(0)}) para calcular correlação.`);
                }

                 // Add shaded rectangle for the region
                 layout.shapes.push({
                    type: 'rect',
                    xref: 'x',
                    yref: 'paper', // Refer to the whole y range
                    x0: end, // Lower wavenumber
                    y0: 0,
                    x1: start, // Higher wavenumber
                    y1: 1,
                    fillcolor: `rgba(147, 197, 253, 0.1)`, // light blue with low opacity (blue-300)
                    line: { width: 0 } // No border
                 });

                 // Add annotation with correlation result
                 // Position annotation slightly above the top, centered in the region
                 layout.annotations.push({
                    x: (start + end) / 2, // Center of the region on x-axis
                    y: 1.05, // Position slightly above the plot area
                    xref: 'x',
                    yref: 'paper',
                    text: annotationText,
                    showarrow: false,
                    font: { size: 10, color: '#90CDF4' }, // blue-300
                    bgcolor: 'rgba(45, 55, 72, 0.7)', // gray-800 semi-transparent background
                    borderpad: 2,
                    borderwidth: 1,
                    bordercolor: '#4A5568' // gray-700
                 });
            });
            // --- End Correlation ---


            Plotly.react(plotDiv, traces, layout).then(gd => {
                 plotInstance = gd; // Store instance for export
                 exportPngButton.disabled = false;
                 exportCsvButton.disabled = false; // Enable CSV export when plot is ready
                 displayMessage('Gráfico atualizado.', 'success');
            }).catch(err => {
                displayMessage(`Erro ao gerar gráfico: ${err.message}`, 'error');
                console.error("Plotly Error:", err);
                 exportPngButton.disabled = true;
                 exportCsvButton.disabled = true;
            });
        }

        // --- Export Functions ---
        function exportTheoreticalCSV() {
             if (!theoreticalSpectrum || theoreticalSpectrum.wavenumbers.length === 0) {
                displayMessage("Nenhum dado teórico para exportar.", "warning");
                return;
            }
             displayMessage("Preparando CSV para exportação...", "info", 0);

            let dataToExport;
            let valueHeader = '';

             // Prepare values based on current display unit
             switch (currentSettings.displayUnit) {
                case 'transmittance':
                    valueHeader = currentSettings.normalize ? 'Transmittance_Normalized' : 'Transmittance_Corrected_Percent';
                     dataToExport = theoreticalSpectrum.values;
                    break;
                 case 'transmittance_norm':
                     valueHeader = 'Transmittance_Normalized';
                    if (!currentSettings.normalize) {
                        displayMessage("Habilite a normalização para exportar como normalizado, exportando como Transmitância %.", "warning", 8000);
                         valueHeader = 'Transmittance_Corrected_Percent';
                         dataToExport = theoreticalSpectrum.values; // Use the T% values
                    } else {
                         dataToExport = theoreticalSpectrum.values; // Values are already 0-1
                     }
                     break;
                 case 'absorbance':
                     valueHeader = 'Absorbance_Corrected';
                     const convertToAbs = (t) => {
                         if (isNaN(t)) return ''; // Represent NaN as empty string in CSV
                        if (currentSettings.normalize) {
                            if (t <= 1e-5) return 5;
                             return -Math.log10(t);
                        } else {
                            return transmittanceToAbsorbance(t);
                        }
                    };
                     dataToExport = theoreticalSpectrum.values.map(convertToAbs);
                     break;
                 default: // Should not happen
                    valueHeader = 'Value';
                    dataToExport = theoreticalSpectrum.values;
            }


            let csvContent = `Wavenumber_cm-1,${valueHeader}\n`;
             theoreticalSpectrum.wavenumbers.forEach((wn, i) => {
                 // Format numbers to avoid excessive precision or scientific notation where not needed
                 const formattedWn = wn.toFixed(4);
                 const val = dataToExport[i];
                 const formattedVal = typeof val === 'number' ? val.toFixed(6) : ''; // Format numbers, keep empty for NaN
                 csvContent += `${formattedWn},${formattedVal}\n`;
             });

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
             link.setAttribute("download", `theoretical_spectrum_${currentSettings.displayUnit}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
             URL.revokeObjectURL(url);
             displayMessage("CSV do espectro teórico exportado.", "success");
        }

         function exportPlotPNG() {
            if (!plotInstance) {
                displayMessage("Nenhum gráfico para exportar.", "warning");
                 return;
            }
            displayMessage("Exportando gráfico como PNG...", "info", 0);
            const ratioString = (currentSettings.mode === 'auto' ? currentSettings.optimizedRatio : currentSettings.manualRatio).toFixed(2);
            const filename = `spectrum_comparison_ratio_${ratioString}_${currentSettings.displayUnit}.png`;

             Plotly.downloadImage(plotInstance, {
                 format: 'png',
                 width: 1200, // Increase resolution for export
                 height: 700,
                 filename: filename
            }).then(() => {
                displayMessage("Gráfico PNG exportado.", "success");
            }).catch(err => {
                displayMessage(`Erro ao exportar PNG: ${err.message}`, 'error');
                console.error("PNG Export Error:", err);
            });
        }

        // --- Initial Setup ---
        displayTransmittanceNormRadio.disabled = !currentSettings.normalize; // Disable normalized view initially if normalization isn't checked
        renderRegionList(); // Render empty list initially

    </script>

</body>
</html>
